/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    private.h

Abstract:

    Contains structure definitions and function prototypes private to
    the driver.

Environment:

    Kernel mode

--*/

#include <initguid.h>
// DMF: DmfModules.Template.h inlcudes DmfModules.Library.h because every library
//      includes dependent libraries.
//
#include <DmfModules.Template.h>
#include <ntddk.h>
// DMF: Note that public.h is no longer necessary as those definitions are in the Template library.
//
#include "driverspecs.h"
#define NTSTRSAFE_LIB
#include <ntstrsafe.h>

#include "trace.h"

//
// Include auto-generated ETW event functions (created by MC.EXE from 
// osrusbfx2.man)
//
#include "fx2Events.h"

#ifndef _PRIVATE_H
#define _PRIVATE_H

#define POOL_TAG (ULONG) 'FRSO'
#define _DRIVER_NAME_ "OSRUSBFX2"

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_CONTEXT {
    //
    // The following fields are used during event logging to 
    // report the events relative to this specific instance 
    // of the device.
    //

    WDFMEMORY                       DeviceNameMemory;
    PCWSTR                          DeviceName;

    WDFMEMORY                       LocationMemory;
    PCWSTR                          Location;

    DMFMODULE                       DmfModuleOsrFx2;
    DMFMODULE                       DmfModulePdo;
    DMFMODULE                       DmfModuleQueuedWorkitem;
} DEVICE_CONTEXT, *PDEVICE_CONTEXT;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_CONTEXT, GetDeviceContext)

extern ULONG DebugLevel;

typedef
NTSTATUS
(*PFN_IO_GET_ACTIVITY_ID_IRP) (
    _In_     PIRP   Irp,
    _Out_    LPGUID Guid
    );

//
// Global function pointer set in DriverEntry
// Check for NULL before using
//
extern PFN_IO_GET_ACTIVITY_ID_IRP g_pIoGetActivityIdIrp;

DRIVER_INITIALIZE DriverEntry;

EVT_WDF_OBJECT_CONTEXT_CLEANUP OsrFxEvtDriverContextCleanup;

EVT_WDF_DRIVER_DEVICE_ADD OsrFxEvtDeviceAdd;

EVT_DMF_OsrFx2_InterruptPipeCallback OsrFx2InterruptPipeCallback;

EVT_DMF_QueuedWorkItem_Callback OsrFx2QueuedWorkitem;

//
// DMF: This is the callback function called by DMF that allows this driver (the Client Driver)
//      to set the CONFIG for each DMF Module the driver will use.
//
EVT_DMF_DEVICE_MODULES_ADD OsrDmfModulesAdd;

_IRQL_requires_(PASSIVE_LEVEL)
VOID
GetDeviceEventLoggingNames(
    _In_ WDFDEVICE Device
    );

_IRQL_requires_(PASSIVE_LEVEL)
PCHAR
DbgDevicePowerString(
    _In_ WDF_POWER_DEVICE_STATE Type
    );

_IRQL_requires_(PASSIVE_LEVEL)
USBD_STATUS
OsrFxValidateConfigurationDescriptor(  
    _In_reads_bytes_(BufferLength) PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
    _In_ ULONG BufferLength,
    _Inout_ PUCHAR *Offset
    );

FORCEINLINE
GUID
RequestToActivityId(
    _In_ WDFREQUEST Request
    )
{
    GUID     activity = {0};
    NTSTATUS status = STATUS_SUCCESS;

    if (g_pIoGetActivityIdIrp != NULL) {

        //
        // Use activity ID generated by application (or IO manager)
        //    
        status = g_pIoGetActivityIdIrp(WdfRequestWdmGetIrp(Request), &activity);
    }

    if (g_pIoGetActivityIdIrp == NULL || !NT_SUCCESS(status)) {

        //
        // Fall back to using the WDFREQUEST handle as the activity ID
        //
        RtlCopyMemory(&activity, &Request, sizeof(WDFREQUEST));
    }


    return activity;
}

FORCEINLINE
GUID
DeviceToActivityId(
    _In_ WDFDEVICE Device
    )
{
    GUID activity = {0};
    RtlCopyMemory(&activity, &Device, sizeof(WDFDEVICE));
    return activity;
}


#endif


